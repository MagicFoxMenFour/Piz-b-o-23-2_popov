# Отчет по лабораторной работе 6

# Деревья. Бинарные деревья поиска

**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Попов Константин Андреевич

## Цель работы

Изучить древовидные структуры данных, их свойства и применение. Освоить основные операции с бинарными деревьями поиска (BST). Получить практические навыки реализации BST на основе узлов (pointer-based), рекурсивных алгоритмов обхода и анализа их эффективности. Исследовать влияние сбалансированности дерева на производительность операций.

## Практическая часть

### Выполненные задачи

* [x] Задача 1: Реализовать бинарное дерево поиска на основе узлов с основными операциями.
* [x] Задача 2: Реализовать различные методы обхода дерева (рекурсивные и итеративные).
* [x] Задача 3: Реализовать дополнительные методы для работы с BST.
* [x] Задача 4: Провести анализ сложности операций для сбалансированного и вырожденного деревьев.
* [x] Задача 5: Визуализировать структуру дерева.

### Ключевые фрагменты кода

```python
# Пример вставки и поиска в BST
tree = BinarySearchTree()
tree.insert(5)
tree.insert(3)
tree.insert(7)
tree.insert(2)
tree.insert(4)
tree.insert(6)
tree.insert(8)

tree.visualize()
```

```python
# Измерение времени поиска в сбалансированном и вырожденном дереве
sizes = [100, 1000, 5000, 10000]
res = run_experiment(sizes, trials_per_size=1000, repeats=3)
```

```python
# Визуализация производительности вставки
sizes = [100, 1000, 5000, 10000, 25000]
visualisation(sizes, out_png="./report/insert.png")
```

<image src="./report/insert.png" style="display:block; margin: auto;">

```
        8
    7
        6
5
        4
    3
        2
            1
n=100: Сбалансированное avg 0.000404s, Вырожденное avg 0.002483s
n=1000: Сбалансированное avg 0.000857s, Вырожденное avg 0.052115s
n=5000: Сбалансированное avg 0.001126s, Вырожденное avg 0.271026s
n=10000: Сбалансированное avg 0.001359s, Вырожденное avg 0.603855s
```

**Характеристики ПК для тестирования:**

* Процессор: Intel Core i5-12500H @ 2.50GHz
* Оперативная память: 32 GB DDR4
* ОС: Windows 11
* Python: 3.12

## Сравнение практической и теоретической сложности операций

| Операция     | Теоретическая сложность (средний случай) | Худший случай (вырожденное дерево) | Практическое поведение                               |
| ------------ | ---------------------------------------- | ---------------------------------- | ---------------------------------------------------- |
| Вставка      | O(log n)                                 | O(n)                               | Обычно близка к O(log n), если дерево сбалансировано |
| Поиск        | O(log n)                                 | O(n)                               | В большинстве случаев быстрее, чем линейный поиск    |
| Удаление     | O(log n)                                 | O(n)                               | Зависит от реализации балансировки и структуры узлов |
| Обход дерева | O(n)                                     | O(n)                               | Всегда линейный, каждый узел посещается один раз     |

**Вывод:**
Сбалансированная структура дерева обеспечивает высокую производительность операций. Вырожденное дерево сильно ухудшает эффективность до O(n).

## Ответы на контрольные вопросы

### 1. Основное свойство бинарного дерева поиска (BST)

Для любого узла дерева:

* Все значения в **левом поддереве** меньше значения узла.
* Все значения в **правом поддереве** больше значения узла.
* Оба поддерева также являются бинарными деревьями поиска.

---

### 2. Алгоритм вставки нового элемента в BST

**Пошагово:**

1. Начать с корня дерева.
2. Если значение меньше текущего узла → левое поддерево.
3. Если больше → правое поддерево.
4. Достигнув `None`, вставить узел.
5. Рекурсивно вернуть обновлённое поддерево.

**Сложность:**

* Сбалансированное дерево: O(log n)
* Вырожденное дерево: O(n)

---

### 3. Обход дерева в глубину (DFS) и в ширину (BFS)

**DFS (Depth-First Search)** — обход в глубину:

* Использует стек (рекурсия или явный стек).
* Варианты:

  * Pre-order: root → left → right
  * In-order: left → root → right
  * Post-order: left → right → root

**BFS (Breadth-First Search)** — обход в ширину:

* Использует очередь.
* Обходит дерево по уровням.

---

### 4. Почему в вырожденном BST сложность O(n)

Если элементы вставляются **в отсортированном порядке**, дерево превращается в цепочку узлов.
Глубина дерева равна n, поэтому вставка, поиск и удаление требуют обхода всех узлов.

---

### 5. Сбалансированное дерево и решение проблемы вырождения

**Сбалансированное дерево** — BST, где разница высот левого и правого поддерева ≤ 1.

**Пример: AVL-дерево**

* После каждой вставки/удаления выполняются повороты для восстановления баланса.
* Гарантированная высота дерева O(log n), операции выполняются быстро и эффективно.
