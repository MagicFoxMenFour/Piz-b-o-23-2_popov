# Отчет по лабораторной работе 8

# Жадные алгоритмы

**Дата:** 2025-11-06
**Семестр:** 3 курс 5 семестр
**Группа:** ПИЖ-б-о-23-2(1)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Попов Константин Андреевич

## Цель работы

Изучить метод проектирования алгоритмов, известный как "жадный алгоритм". Освоить принцип принятия локально оптимальных решений на каждом шаге и понять условия, при которых этот подход приводит к глобально оптимальному решению. Получить практические навыки реализации жадных алгоритмов для решения классических задач, анализа их корректности и оценки эффективности.

## Практическая часть

### Выполненные задачи

* [x] Реализованы классические жадные алгоритмы: алгоритм Хаффмана, непрерывный рюкзак, задача о выборе заявок, жадный подход к сдаче монет, алгоритм Прима.
* [x] Проведен анализ корректности жадного выбора и доказано, когда он приводит к оптимальному решению.
* [x] Выполнено сравнение эффективности жадного подхода с точными методами (перебор, динамика).
* [x] Решены практические задачи с применением жадного подхода.

### Ключевые фрагменты кода

```python
# Пример: выбор непересекающихся интервалов
def interval_scheduling(intervals):
    intervals.sort(key=lambda x: x[1])
    selected = []
    last_end = float('-inf')
    for start, end in intervals:
        if start >= last_end:
            selected.append((start, end))
            last_end = end
    return selected
```

```python
# Пример: непрерывный рюкзак
def fractional_knapsack(items, capacity):
    items.sort(key=lambda x: x[0]/x[1], reverse=True)
    total_value = 0.0
    for value, weight in items:
        if capacity == 0:
            break
        if weight <= capacity:
            total_value += value
            capacity -= weight
        else:
            total_value += value * (capacity / weight)
            capacity = 0
    return total_value
```

```python
# Пример: алгоритм Хаффмана
import heapq
class Node:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None
    def __lt__(self, other):
        return self.freq < other.freq

def huffman_coding(frequencies):
    heap = [Node(c, f) for c, f in frequencies.items()]
    heapq.heapify(heap)
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(None, left.freq + right.freq)
        merged.left = left
        merged.right = right
        heapq.heappush(heap, merged)
    root = heap[0]
    codes = {}
    def generate_codes(node, code=""):
        if node.char is not None:
            codes[node.char] = code
            return
        generate_codes(node.left, code + "0")
        generate_codes(node.right, code + "1")
    generate_codes(root)
    return codes
```

### Пример результатов работы алгоритмов

* **Выбранные интервалы:** `[(119, 135), (265, 292), (404, 441), ...]`
* **Максимальная стоимость рюкзака:** `223.04`
* **Коды Хаффмана:**

```
M: 000
U: 001
K: 010
...
```

* **Сдача:** `[10, 10, 5, 2, 1]`
* **Минимальное остовное дерево (Prim):**

```
0 - 1 (вес 2)
1 - 2 (вес 3)
0 - 3 (вес 6)
1 - 4 (вес 5)
Суммарный вес MST: 16
```

### Временные сложности и обоснование корректности

| Алгоритм             | Временная сложность | Обоснование корректности жадного выбора                                                                               |
| -------------------- | ------------------- | --------------------------------------------------------------------------------------------------------------------- |
| Хаффмана             | O(n log n)          | На каждом шаге объединяются два узла с наименьшими частотами, минимизируя рост длины кодов.                           |
| Непрерывный рюкзак   | O(n log n)          | Берем предметы с максимальной удельной стоимостью; дробные части позволяют локальный оптимум превращать в глобальный. |
| Задача выбора заявок | O(n log n)          | Выбираем интервалы с наименьшим временем окончания, что освобождает место для следующих.                              |
| Жадная сдача монет   | O(n)                | Берем наибольшую монету; корректно для канонических систем монет.                                                     |
| Алгоритм Прима       | O(V^2) / O(E log V) | На каждом шаге добавляем минимальное ребро, соединяющее MST с остальными вершинами; гарантирует MST.                  |

### Анализ корректности

* **Хаффман:** локальная оптимальность (объединение минимальных частот) → глобальный минимальный средний код.
* **Непрерывный рюкзак:** локальный выбор максимальной ценности/веса → глобальный максимум стоимости.
* **Interval Scheduling:** локальный выбор раннего окончания → максимальное количество непересекающихся интервалов.

### Сравнение эффективности жадных алгоритмов с точными методами

| Алгоритм            | Жадный подход       | Точный метод              | Сложность                                               | Комментарий |
| ------------------- | ------------------- | ------------------------- | ------------------------------------------------------- | ----------- |
| Interval Scheduling | O(n log n)          | O(2^n) перебор            | Жадный алгоритм оптимален, быстрее при больших n        |             |
| Fractional Knapsack | O(n log n)          | O(2^n) перебор            | Жадный алгоритм оптимален только для дробного рюкзака   |             |
| Хаффман             | O(n log n)          | Непрактично               | Жадный выбор минимальных частот дает оптимальный код    |             |
| Coin Change         | O(n)                | O(2^n) перебор            | Работает корректно только для канонических систем монет |             |
| MST (Prim)          | O(V^2) / O(E log V) | Проверка всех подмножеств | Жадный подход всегда дает MST                           |             |

### Ограничения жадного подхода

* Локальная оптимальность не всегда ведет к глобальной (0-1 рюкзак, нестандартные монеты).
* Требуется правильная структура данных или критерий выбора (сдача монет, удельная стоимость).
* Не применим ко всем задачам оптимизации (коммивояжер, задачи с зависимостями).
* Чувствителен к критерию сортировки (неправильная сортировка может дать неоптимальный результат).

### Контрольные вопросы

1. **Основная идея:** жадный алгоритм делает локально оптимальный выбор на каждом шаге, стремясь к глобальному оптимуму.
2. **Interval Scheduling:** выбираем интервалы с минимальным временем окончания; это гарантирует максимальное количество совместимых интервалов.
3. **Примеры:**

   * Interval Scheduling → оптимально
   * Fractional Knapsack → оптимально
   * 0-1 Knapsack → не оптимально
   * Coin Change нестандартная система → не оптимально
4. **Непрерывный vs 0-1 рюкзак:** дробный рюкзак позволяет брать части предметов, жадный алгоритм оптимален; дискретный рюкзак требует перебора/динамики, жадный не всегда оптимален.
5. **Хаффман:** объединяем минимальные частоты на каждом шаге → минимальная средняя длина префиксного кода.

### Характеристики ПК для тестирования

* Процессор: Intel Core i5-11500H @ 2.50GHz
* Оперативная память: 8 GB DDR4
* ОС: Windows 11
* Python: 3.12

<image src="./report/Huffman.png" style="display:block; margin: auto;">
