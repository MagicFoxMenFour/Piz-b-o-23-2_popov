
# Лабораторная работа №4

**Тема:** Алгоритмы сортировки
**Студент:** Попов Константин Андреевич
**Курс:** 3 курс, ПИЖ-б-о-23-2

## Цель работы

Изучить и реализовать основные алгоритмы сортировки.
Провести теоретический и практический сравнительный анализ по временной и пространственной сложности.
Исследовать влияние начальной упорядоченности данных на эффективность алгоритмов.
Получить навыки эмпирического анализа производительности алгоритмов.

---

## Теоретическая часть

### Сложность алгоритмов сортировки

Сложность алгоритма характеризует количество ресурсов (времени и памяти), необходимых для обработки данных объема n.

**Основные виды сортировок в работе:**

* **Bubble Sort** — сортировка пузырьком. Сложность O(n²) в худшем и среднем случае, O(n) в лучшем; память O(1).
* **Selection Sort** — сортировка выбором. Сложность O(n²) для всех случаев; память O(1).
* **Insertion Sort** — сортировка вставками. Сложность O(n²) худший/средний, O(n) лучший; память O(1).
* **Merge Sort** — сортировка слиянием. Сложность O(n log n) для всех случаев; память O(n).
* **Quick Sort** — быстрая сортировка. Сложность O(n log n) средний и лучший, O(n²) худший; память O(log n).

### Поведение на разных входных данных

* **Случайные массивы** — Quick Sort быстрее всего.
* **Отсортированные массивы** — Insertion Sort максимально эффективен.
* **Обратно отсортированные** — Merge Sort или Quick Sort с рандомизацией pivot.
* **Почти отсортированные** — Insertion Sort работает почти линейно.

---

## Практическая часть

### Шаги выполнения

1. Создан файл `sorts.py` с реализацией всех алгоритмов сортировки.
2. Созданы функции генерации массивов разного типа в `generate_data.py` (случайный, отсортированный, реверс, почти отсортированный).
3. Проведен анализ времени выполнения алгоритмов в `perfomance_test.py` с использованием `timeit`.
4. Построены графики времени выполнения сортировок для каждого типа данных.
5. Выведена сводная таблица результатов в консоль.

---

### Результаты экспериментов

**Характеристики ПК:**

* Процессор: Intel Core i5-12500H @ 2.50GHz
* Оперативная память: 32 GB DDR4
* ОС: Windows 11
* Python: 3.12

**Замеры времени (мс)**

| Тип данных    | Размер | Bubble  | Select  | Insert  | Merge | Quick |
| ------------- | ------ | ------- | ------- | ------- | ----- | ----- |
| random        | 100    | 0.89    | 0.32    | 0.12    | 0.10  | 0.12  |
| random        | 1000   | 43.95   | 26.23   | 13.90   | 1.06  | 1.41  |
| random        | 5000   | 1007.83 | 370.98  | 386.78  | 6.78  | 9.35  |
| random        | 10000  | 4129.67 | 1351.99 | 1710.37 | 15.63 | 23.42 |
| sorted        | 100    | 0.25    | 0.15    | 0.01    | 0.09  | 0.08  |
| sorted        | 1000   | 26.40   | 12.51   | 0.08    | 0.98  | 0.88  |
| sorted        | 5000   | 526.58  | 316.93  | 0.39    | 4.92  | 4.31  |
| sorted        | 10000  | 2410.78 | 1454.70 | 0.77    | 12.70 | 10.36 |
| reversed      | 100    | 0.27    | 0.16    | 0.47    | 0.13  | 0.17  |
| reversed      | 1000   | 44.02   | 14.71   | 41.67   | 1.27  | 0.68  |
| reversed      | 5000   | 1314.27 | 449.46  | 818.36  | 8.23  | 5.41  |
| reversed      | 10000  | 5413.76 | 1684.06 | 3490.52 | 15.46 | 10.07 |
| almost_sorted | 100    | 0.15    | 0.18    | 0.03    | 0.13  | 0.07  |
| almost_sorted | 1000   | 22.91   | 15.26   | 1.70    | 1.18  | 0.72  |
| almost_sorted | 5000   | 618.79  | 406.14  | 51.53   | 6.89  | 5.05  |
| almost_sorted | 10000  | 2687.90 | 1411.84 | 210.46  | 14.08 | 10.87 |

**Графики результатов:** <image src="./report/random_data_all_methods.png" style="display:block; margin:auto; height:400px"> <image src="./report/sorted_data_all_methods.png" style="display:block; margin:auto; height:400px"> <image src="./report/reversed_data_all_methods.png" style="display:block; margin:auto; height:400px"> <image src="./report/almost_sorted_data_all_methods.png" style="display:block; margin:auto; height:400px">

---

## Анализ эффективности

| Алгоритм       | Средняя сложность | Худшая сложность | Подходит для                         | Примечания                                                  |
| -------------- | ----------------- | ---------------- | ------------------------------------ | ----------------------------------------------------------- |
| Bubble Sort    | O(n²)             | O(n²)            | Малые массивы, почти отсортированные | Прост в реализации, медленный на больших данных             |
| Selection Sort | O(n²)             | O(n²)            | Малые массивы                        | Количество сравнений не зависит от входных данных           |
| Insertion Sort | O(n²)             | O(n²)            | Почти отсортированные, малые массивы | Быстрый на почти отсортированных данных                     |
| Merge Sort     | O(n log n)        | O(n log n)       | Любые типы данных                    | Стабильный, требует дополнительную память                   |
| Quick Sort     | O(n log n)        | O(n²)            | Случайные данные                     | Быстрее Merge Sort на практике, чувствителен к выбору pivot |

**Выводы:**

* Quick Sort — лучший для случайных данных.
* Insertion Sort — лучший для почти отсортированных массивов.
* Merge Sort — предсказуемое время для любых данных, стабильный.
* Bubble и Selection Sort подходят только для малых объемов данных.

---

## Контрольные вопросы

1. **Алгоритмы со сложностью O(n²) в худшем случае:** Bubble, Selection, Insertion, Quick (при плохом pivot).
   **Алгоритмы O(n log n):** Merge, Quick (с хорошим pivot).

2. **Почему Insertion Sort эффективен для маленьких/почти отсортированных массивов:**
   Минимальное количество перестановок, близко к O(n), простота реализации.

3. **Устойчивая vs неустойчивая сортировка:**
   Устойчивая сохраняет порядок одинаковых ключей (Bubble, Insertion, Merge), неустойчивая может менять (Selection, Quick).

4. **Принцип Quick Sort:**
   Разделение массива на меньше/больше относительно pivot, рекурсивная сортировка частей. Выбор pivot критичен для производительности.

5. **Когда Merge Sort предпочтительнее Quick Sort:**
   Необходима устойчивость, предсказуемое время, работа с внешними данными, избежание деградации до O(n²).

