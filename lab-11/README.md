# Лабораторная работа №11

**Тема:** Алгоритмы на строках
**Студент:** Попов Константин Андреевич
**Курс:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов

---

## Цель работы

* Изучить алгоритмы эффективной работы со строками.
* Освоить методы поиска подстрок: KMP, Z-функция, Boyer-Moore.
* Научиться вычислять префикс-функцию и Z-функцию.
* Получить практические навыки анализа и сравнения производительности алгоритмов.

---

## Теоретическая часть

### Алгоритмы работы со строками

**Префикс-функция**
Массив π для строки `s` длины n, где π[i] = длина наибольшего собственного префикса строки `s[0..i]`, совпадающего с её суффиксом. Используется в KMP для пропуска повторных сравнений.

**Алгоритм Кнута-Морриса-Пратта (KMP)**
Поиск шаблона в тексте с использованием префикс-функции. Сложность:

* Время: O(n + m)
* Память: O(m)

**Z-функция**
Массив Z[i] = длина наибольшего префикса строки, совпадающего с префиксом s[i..n-1]. Применяется для поиска подстроки и анализа повторов.
Сложность: O(n + m), память O(n + m).

**Алгоритм Бойера-Мура**
Сравнивает шаблон справа налево и использует эвристики:

* Bad character (плохой символ)
* Good suffix (хороший суффикс)
  Эффективен для больших текстов и шаблонов. Сложность: O(n) в среднем, O(n*m) в худшем.

**Наивный поиск**
Последовательный перебор всех возможных позиций. Сложность: O(n*m), память O(1).

---

## Практическая часть

### Задание

1. Реализовать вычисление префикс-функции строки.
2. Реализовать алгоритм KMP.
3. Реализовать Z-функцию и поиск с её помощью.
4. Реализовать алгоритм Бойера-Мура.
5. Провести сравнительный анализ алгоритмов на случайных строках разного размера.
6. Найти минимальный период строки и проверить циклический сдвиг.

---

### Шаги выполнения

1. Созданы модули: `prefix_function.py`, `kmp_search.py`, `z_function.py`, `boier_mura.py`, `perfomance_analysis.py`, `string_matching.py`.
2. Реализованы функции с комментариями сложности.
3. Сгенерированы случайные строки разных размеров:

   * Тексты: [1000, 5000, 10000, 20000, 50000, 100000, 200000]
   * Шаблоны: [5, 10, 20, 50, 100, 200, 500, 1000]
4. Замеры времени усреднены по 10 повторов с использованием `timeit`.
5. Построены графики зависимости времени выполнения от размера текста и шаблона.

---

### Ключевые результаты

**Пример поиска подстроки:**

```python
string = "acabababcababc"
pattern = "abcab"
kmp_search(pattern, string)       # [6]
naive_search(pattern, string)     # [6]
find_substring_z(pattern, string) # [6]
boier_mura(pattern, string)       # [6]
```

**Нахождение минимального периода строки:**

```python
string_for_period = "abcabcabcabc"
period_length = find_period(string_for_period)  # 3
```

**Циклический сдвиг:**

```python
cyclic_shift("abcd", "cdab")  # True
```

---

### Результаты экспериментов

**Характеристики ПК:**

* Процессор: Intel Core i5-12500H @ 2.50GHz
* ОЗУ: 32 GB DDR4
* ОС: Windows 11
* Python: 3.12

**Замеры времени (мс) для фиксированного паттерна:**

| Размер текста (N) | KMP    | Naive  | Z-функция | Boyer-Moore |
| ----------------- | ------ | ------ | --------- | ----------- |
| 1000              | 1.28   | 2.26   | 3.97      | 0.97        |
| 5000              | 7.29   | 15.16  | 22.34     | 5.29        |
| 10000             | 16.63  | 35.18  | 69.80     | 19.03       |
| 50000             | 84.64  | 154.40 | 254.76    | 30.08       |
| 100000            | 159.13 | 353.43 | 424.51    | 52.36       |

**Замеры времени (мс) для фиксированного текста:**

| Размер паттерна (M) | KMP    | Naive  | Z-функция | Boyer-Moore |
| ------------------- | ------ | ------ | --------- | ----------- |
| 5                   | 109.43 | 150.75 | 231.95    | 54.97       |
| 10                  | 97.92  | 190.41 | 326.68    | 106.96      |
| 20                  | 106.70 | 206.81 | 322.98    | 86.54       |
| 50                  | 107.66 | 200.74 | 329.43    | 51.63       |
| 100                 | 107.72 | 199.87 | 335.71    | 77.68       |

**Графики производительности:**

* Время выполнения растёт с увеличением текста.
* KMP и Z-функция линейны.
* Boyer-Moore быстрее на больших текстах.
* Наивный поиск значительно медленнее при больших текстах и паттернах.

---

### Анализ влияния характеристик строк на производительность

| Характеристика          | Naive                              | KMP                      | Z-функция    | Boyer-Moore                   |
| ----------------------- | ---------------------------------- | ------------------------ | ------------ | ----------------------------- |
| Длина текста (n)        | O(n*m)                             | O(n+m)                   | O(n+m)       | Почти O(n)                    |
| Длина шаблона (m)       | Прямое влияние                     | Префикс O(m), поиск O(n) | Зависит от m | Длинный шаблон ускоряет поиск |
| Размер алфавита         | Не влияет                          | Не влияет                | Не влияет    | Большой алфавит → быстрее     |
| Повторяющиеся подстроки | Худший случай                      | Эффективно               | Эффективно   | Замедляет эвристику           |
| Распределение символов  | Редкие совпадения → мало ускорения | Не влияет                | Не влияет    | Редкие совпадения → быстрее   |

**Оптимальная область применения:**

| Алгоритм    | Применение                                                   |
| ----------- | ------------------------------------------------------------ |
| Naive       | Короткие строки и шаблоны, одноразовый поиск                 |
| KMP         | Длинные тексты с повторяющимися подстроками                  |
| Z-функция   | Поиск всех вхождений, анализ повторов                        |
| Boyer-Moore | Большие тексты и длинные шаблоны, быстрый практический поиск |

---

### Ответы на контрольные вопросы

1. **Префикс-функция** — длина наибольшего собственного префикса, совпадающего с суффиксом. Используется в KMP для пропуска повторных сравнений.
2. **Преимущество KMP перед наивным поиском:** O(n+m) против O(n*m), минимальные повторные сравнения.
3. **Z-функция** — длина наибольшего префикса строки, совпадающего с текущей позицией; позволяет быстро искать шаблон в тексте.
4. **Идея Boyer-Moore:** сравнение справа налево, использование эвристик Bad character и Good suffix для ускорения сдвигов.
5. **Практическое применение префикс- и Z-функций:** поиск периодов строки, поиск подстрок, анализ текстов, сжатие данных, синтаксический анализ.

---

### Выводы

* Алгоритмы KMP, Z-функция и Boyer-Moore позволяют эффективно искать подстроки.
* Наивный поиск применим только для небольших текстов.
* Практические замеры полностью подтверждают теоретические оценки сложности.
* Выбор алгоритма зависит от размера текста, шаблона и структуры данных.

---
