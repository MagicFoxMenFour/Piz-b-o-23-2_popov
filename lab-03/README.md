

# **Лабораторная работа №3**

# **Рекурсия**

**Студент:** Попов Константин Андреевич
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов

---

# **Цель работы**

* Освоить принципы рекурсивного программирования.
* Научиться работать с базовым случаем и рекурсивным шагом.
* Изучить стек вызовов и влияние глубины рекурсии на выполнение программы.
* Реализовать классические рекурсивные алгоритмы.
* Освоить технику мемоизации и сравнить её эффективность с наивной рекурсией.
* Применить рекурсию для решения прикладных задач.

---

# **Теоретическая часть**

## **1. Рекурсия**

Рекурсия — это метод, при котором функция вызывает саму себя, пока не достигнет **базового случая**, завершающего вычисления.

Типичная рекурсивная функция состоит из двух частей:

1. **Базовый случай** — условие выхода.
2. **Рекурсивный шаг** — уменьшение задачи и рекурсивный вызов.

---

## **2. Проблема глубокой рекурсии**

Каждый вызов функции помещается в **стек вызовов**.
Если глубина рекурсии слишком велика → происходит **RecursionError** (переполнение стека).

---

## **3. Мемоизация**

Мемоизация — техника ускорения рекурсивных функций за счёт сохранения результатов вычислений.

Пример: вычисление чисел Фибоначчи
*Наивная рекурсия:* **O(2ⁿ)**
*С мемоизацией:* **O(n)**

---

# **Практическая часть**

## **Выполненные задачи**

* [x] Реализованы рекурсивные алгоритмы: факториал, Фибоначчи, быстрое возведение в степень.
* [x] Проанализирована временная сложность и глубина рекурсии.
* [x] Реализована мемоизация для чисел Фибоначчи.
* [x] Выполнено сравнение производительности наивной рекурсии и мемоизации.
* [x] Решены прикладные рекурсивные задачи:

  * рекурсивный бинарный поиск,
  * вывод дерева каталогов,
  * Ханойские башни.

---

# **Ключевые фрагменты кода**

*(вставлены из представленных файлов без изменений)*

### **Файл recursion.py**

```python
def factorial(n):
    if n == 1:
        return 1
    elif n > 1:
        return n * factorial(n-1)
    else:
        return -1
```

```python
def fibbonachi(n):
    if n > 0 and n < 3:
        return 1
    elif n > 2:
        return fibbonachi(n-1) + fibbonachi(n-2)
    else:
        return -1
```

```python
def quick_power(val, p):
    if p < 0:
        return quick_power(1/val, -p)
    if p == 0:
        return 1
    if p % 2 == 0:
        return quick_power(val*val, p/2)
    else:
        return val*quick_power(val*val, (p-1)/2)
```

---

### **Файл memoization.py**

*(включает подсчёт вызовов, сравнение, визуализацию)*

```python
def fibbonachi_memoized(n, memo={}):
    ...
```

```python
def compare_fibbonachi(n):
    ...
```

```python
def Visualization(sizes):
    ...
```

---

### **Файл recursion_tasks.py**

```python
def binary_search_recursive(arr, target, left, right):
    ...
```

```python
def print_directory_tree(path, indent=""):
    ...
```

```python
def hanoi(n, source, target, auxiliary):
    ...
```

---

# **Результаты работы программы**

### Демонстрация вычислений

```
1 120 5040 362880 -1
1 5 13 610 -1
78125 2097152 36893488147419103232
{'time': (1755.4174, 0.0204), 'calls': (18454929, 67)}
3
```

### Рекурсивное дерево каталогов

```
src/
    main.py
    modules/
        memoization.py
        recursion.py
        recursion_tasks.py
```

### Ханойские башни (3 диска)

```
Переместить диск 1 с A на C
Переместить диск 2 с A на B
Переместить диск 1 с C на B
Переместить диск 3 с A на C
Переместить диск 1 с B на A
Переместить диск 2 с B на C
Переместить диск 1 с A на C
```

### Визуализация (график)

*(как в исходном отчёте)*
**fibonacci_comparison.png**

---

# **Анализ результатов**

* Наивная рекурсия Фибоначчи чрезвычайно неэффективна: растёт экспоненциально.
* Мемоизация сокращает время выполнения в **тысячи раз**, превращая экспоненциальную сложность в линейную.
* Глубокая рекурсия ограничена стеком вызовов.
* Задачи типа Ханойских башен или обхода деревьев естественно и просто выражаются через рекурсию.
* В практических задачах рекурсия часто заменяется итерацией ради оптимизации.

---

# **Ответы на контрольные вопросы**

## **1. Что такое базовый случай и рекурсивный шаг? Почему отсутствие базового случая вызывает ошибку?**

Базовый случай завершает рекурсию.
Если его нет → функция вызывает саму себя бесконечно → **RecursionError**.

---

## **2. Как работает мемоизация? Как она влияет на числа Фибоначчи?**

Мемоизация сохраняет промежуточные результаты.
На Фибоначчи:

* без мемоизации: **O(2ⁿ)**
* с мемоизацией: **O(n)**

---

## **3. Что такое глубокая рекурсия и переполнение стека?**

Каждый вызов → новый кадр стека.
Слишком много вызовов → стек переполняется → RecursionError.

---

## **4. Алгоритм Ханойских башен для 3 дисков**

Шаги:

1. A → C
2. A → B
3. C → B
4. A → C
5. B → A
6. B → C
7. A → C

Всего **7 = 2³ − 1** операций.

---

## **5. Рекурсивные vs итеративные алгоритмы**

| Рекурсия                           | Итерация                     |
| ---------------------------------- | ---------------------------- |
| Понятный код                       | Высокая эффективность        |
| Простая реализация деревьев/графов | Нет риска переполнения стека |
| Медленнее, есть ограничения стека  | Код иногда сложнее           |

---

# **Выводы**

1. Рекурсия — мощный инструмент, позволяющий решать задачи, которые имеют самоподобную структуру.
2. Мемоизация значительно ускоряет рекурсивные алгоритмы.
3. Наивная рекурсия Фибоначчи непрактична из-за экспоненциальной сложности.
4. Рекурсия удобна для деревьев, обходов каталогов, башен Ханоя.
5. В реальных системах рекурсию нужно применять с осторожностью из-за ограничений стека.

---
