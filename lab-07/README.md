# Отчёт по лабораторной работе 7 — Кучи (Heaps)

**Студент:** Попов Константин Андреевич
**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов

---

## Цель работы

Изучить структуру данных «куча», её свойства и применение. Освоить операции вставки, извлечения корня и построения кучи из массива. Реализовать кучу на основе массива, изучить эффективность операций и применение кучи для сортировки (Heapsort) и приоритетной очереди.

---

## Практическая часть

### Выполненные задачи

* ✅ Реализована структура данных «куча» (min-heap и max-heap) на основе массива.
* ✅ Реализованы операции: вставка (`insert`), извлечение (`extract`), просмотр корня (`peek`) и построение кучи из массива (`build_heap`).
* ✅ Реализован алгоритм сортировки кучей (Heapsort) как с выделением дополнительной памяти, так и in-place.
* ✅ Проведен анализ сложности операций.
* ✅ Сравнена производительность сортировки кучей с QuickSort и MergeSort.

---

### Ключевые фрагменты кода

* **Heap** — двоичная куча (min/max):

```python
heap = Heap(is_min=True)
heap.build_heap([5, 2, 9, 1, 7, 6, 3])
heap.visualize()
```

* **Heapsort** — сортировка массива с использованием кучи:

```python
sorted_array = heapsort([9, 5, 7, 3, 2])
sorted_array_in_place = heapsort_in_place([9, 5, 7, 3, 2])
```

* **PriorityQueue** — реализация приоритетной очереди на куче:

```python
pq = PriorityQueue(is_min=False)
pq.enqueue("task1", 5)
pq.enqueue("task2", 10)
top = pq.dequeue()
```

* **Сравнение с другими сортировками:**

```python
from sorts import quick_sort, merge_sort

arr = [random.randint(0, 1000) for _ in range(1000)]
quick_sorted = quick_sort(arr.copy())
merge_sorted = merge_sort(arr.copy())
heap_sorted = heapsort(arr.copy())
```

---

### Результаты экспериментов

**Сравнение построения кучи (`insert` vs `build_heap`):**

<image src="./report/creating_heap.png" style="display:block; margin: auto;">

* `build_heap` заметно быстрее последовательных вставок, особенно на больших объемах данных.
* Теория подтверждается: `build_heap` O(n), `insert` O(n log n).

**Сравнение сортировок:**

<image src="./report/sorting.png" style="display:block; margin: auto;">

* QuickSort быстрее Heapsort и MergeSort на случайных данных.
* Heapsort стабильнее по использованию памяти и гарантированно O(n log n).

**Сравнение операций кучи (`insert`, `peek`, `extract`):**

<image src="./report/heap_operations.png" style="display:block; margin: auto;">

* `peek` почти не зависит от размера.
* `insert` и `extract` растут логарифмически, что соответствует теории.

---

## 1. Сравнение практической и теоретической сложности операций

| Операция                | Теория     | Практика                        | Соответствие |
| ----------------------- | ---------- | ------------------------------- | ------------ |
| insert                  | O(log n)   | Растет логарифмически           | Да           |
| peek                    | O(1)       | Почти постоянное                | Да           |
| extract                 | O(log n)   | Логарифмический рост            | Да           |
| build_heap              | O(n)       | Быстрее последовательных insert | Да           |
| Последовательные insert | O(n log n) | Существенно дольше              | Да           |

**Вывод:** Практика подтверждает теорию.

---

## 2. Разница во времени между методами построения кучи

* **Последовательные insert**: каждый элемент восстанавливает свойство кучи → O(n log n).
* **build_heap**: "просеивание вниз" половины элементов → O(n).

**Вывод:** build_heap значительно эффективнее за счёт обработки элементов снизу вверх.

---

## 3. Эффективность Heapsort

| Алгоритм  | Теория           | Практика                            | Примечание             |
| --------- | ---------------- | ----------------------------------- | ---------------------- |
| Heapsort  | O(n log n)       | Стабильно, чуть медленнее QuickSort | Не требует доп. памяти |
| QuickSort | O(n log n)/O(n²) | Быстрее на случайных данных         | Использует рекурсию    |
| MergeSort | O(n log n)       | Чуть медленнее QuickSort            | Требует O(n) памяти    |

**Вывод:** Heapsort надёжен, но в большинстве случаев QuickSort быстрее.

---

## Контрольные вопросы

1. **Свойства кучи:**

   * Min-куча: корень ≤ всех потомков.
   * Max-куча: корень ≥ всех потомков.

2. **Алгоритм вставки (`sift_up`):**

   * Добавить элемент в конец массива, сравнивать с родителем, менять местами при нарушении свойства кучи до корня.
   * Сложность: O(log n).

3. **Почему build_heap O(n):**

   * Листья не обрабатываются.
   * Элементы на нижних уровнях просеиваются на короткое расстояние.
   * Суммарное время ~ 2n = O(n).

4. **Heapsort:**

   * Построить max-кучу → менять корень с последним элементом → восстанавливать свойство кучи.
   * Сложность: O(n log n), in-place, нестабильная сортировка.

5. **Куча и приоритетная очередь:**

   * Элемент с наивысшим приоритетом в корне.
   * Вставка и извлечение: O(log n), просмотр: O(1).
   * Куча идеально подходит для реализации приоритетной очереди.

---
