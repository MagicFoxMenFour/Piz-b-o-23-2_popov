# Отчёт по лабораторной работе 9

# Динамическое программирование

**Группа:** ПИЖ-б-о-23-2(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Попов Константин Андреевич

---

## Цель работы

Изучить метод динамического программирования (ДП) как инструмент решения сложных задач через разбиение на перекрывающиеся подзадачи. Освоить нисходящий (с мемоизацией) и восходящий (табличный) подходы. Получить практические навыки построения таблиц ДП, восстановления решений и анализа временной и пространственной сложности алгоритмов.

---

## Практическая часть

### Основные задачи и реализованные алгоритмы

1. **Числа Фибоначчи**

   * Наивная рекурсия (`O(2^n)`), мемоизация (`O(n)`), табуляция (`O(n)`).
2. **Задача о рюкзаке 0-1**

   * Восстановление максимальной стоимости и выбранных предметов.
   * Одномерная оптимизация по памяти.
3. **Наибольшая общая подпоследовательность (LCS)**

   * Определение длины и самой последовательности.
4. **Расстояние Левенштейна**

   * Минимальное количество операций вставки, удаления, замены.
5. **Размен монет (Coin Change)**

   * Минимальное количество монет для заданной суммы.
6. **Наибольшая возрастающая подпоследовательность (LIS)**

   * Длина и сама подпоследовательность.

---

### Ключевые результаты

* **Фибоначчи (Top-Down vs Bottom-Up)**

| n   | Top-Down время (мс) | Bottom-Up время (мс) | Top-Down память (КБ) | Bottom-Up память (КБ) |
| --- | ------------------- | -------------------- | -------------------- | --------------------- |
| 100 | 0.094               | 0.054                | 9.07                 | 3.80                  |
| 200 | 0.211               | 0.079                | 19.40                | 8.87                  |
| 300 | 0.396               | 0.166                | 22.80                | 14.84                 |
| 400 | 0.790               | 0.280                | 46.32                | 21.70                 |
| 500 | 1.459               | 0.411                | 51.10                | 29.47                 |
| …   | …                   | …                    | …                    | …                     |

* **0-1 Рюкзак (capacity=50)**

| Алгоритм | Максимальная стоимость | Выбранные предметы  |
| -------- | ---------------------- | ------------------- |
| Жадный   | 160                    | [(60,10),(100,20)]  |
| ДП       | 220                    | [(100,20),(120,30)] |

* **LCS**
  Входные строки: `"AGGTAB"` и `"GXTXAYB"`
  Длина LCS = 4, последовательность = `"GTAB"`

* **Coin Change**
  Монеты `[1,2,5]`, сумма `11` → минимальное количество монет = 3

* **LIS**
  Последовательность `[10,22,9,33,21,50,41,60]`
  Длина LIS = 5, последовательность = `[10,22,33,50,60]`

---

### Графические результаты анализа производительности

* **Фибоначчи (Top-Down vs Bottom-Up)** <img src="./report/fib_analysis.png" style="display:block; margin: auto;">

* **Фибоначчи (Tabulation)** <img src="./report/fib_tabulation_analysis.png" style="display:block; margin: auto;">

* **0-1 Рюкзак** <img src="./report/knapsack_analysis.png" style="display:block; margin: auto;">

* **LCS** <img src="./report/lcs_analysis.png" style="display:block; margin: auto;">

* **Левенштейн** <img src="./report/levenshtein_analysis.png" style="display:block; margin: auto;">

---

## Сравнение подходов динамического программирования

### 1. Основные характеристики

| Критерий                            | Top-Down (мемоизация)                  | Bottom-Up (табуляция)           |
| ----------------------------------- | -------------------------------------- | ------------------------------- |
| Принцип работы                      | Рекурсия с кэшированием                | Итеративное заполнение таблицы  |
| Стек вызовов                        | Используется                           | Не используется                 |
| Память                              | Динамическая (только нужные подзадачи) | Фиксированная (все подзадачи)   |
| Эффективность при редких подзадачах | Лучше                                  | Хуже                            |
| Удобство восстановления решения     | Сложнее                                | Легче                           |
| Оптимизация памяти                  | Сложнее                                | Rolling array легко реализуется |

### 2. Вывод

* **Top-Down**: проще в реализации, экономит время при редких подзадачах.
* **Bottom-Up**: более предсказуемое использование памяти и времени, лучше для больших данных и промышленного применения.

---

## Контрольные вопросы

1. **Свойства задачи для применения ДП**

   * **Оптимальная подструктура**: решение задачи строится из решений подзадач.
   * **Перекрывающиеся подзадачи**: одни и те же подзадачи повторяются многократно.

2. **Разница Top-Down и Bottom-Up**

   * Top-Down: рекурсивно, с мемоизацией, вычисляет только нужные подзадачи.
   * Bottom-Up: итеративно, заполняет таблицу полностью, более предсказуемо по памяти.

3. **Оптимальная подструктура рюкзака 0-1**
   `dp[i][w] = max(dp[i-1][w], value[i] + dp[i-1][w-weight[i]])` — решение для n предметов строится из оптимальных решений меньших подзадач.

4. **Построение таблицы LCS**

   * Таблица `dp[m+1][n+1]`, `dp[i][j]` = длина LCS первых i символов строки A и первых j символов строки B.
   * Если символы совпадают, `dp[i][j] = dp[i-1][j-1]+1`, иначе `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`.
   * Восстановление последовательности — обратный проход по таблице.

5. **Снижение сложности вычисления Фибоначчи**

   * Мемоизация или табуляция → `O(n)` по времени и памяти (или `O(1)` при оптимизации).
   * Быстрое возведение матриц → `O(log n)`.

---

### Характеристики ПК для тестирования

* Процессор: Intel Core i5-11500H @ 2.50GHz
* Оперативная память: 8 GB DDR4
* ОС: Windows 11
* Python: 3.12
